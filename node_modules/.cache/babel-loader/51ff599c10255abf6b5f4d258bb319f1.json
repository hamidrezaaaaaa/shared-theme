{"ast":null,"code":"import { copyConfig } from '../moment/constructor';\nimport { configFromStringAndFormat } from './from-string-and-format';\nimport getParsingFlags from './parsing-flags';\nimport { isValid } from './valid';\nimport extend from '../utils/extend'; // date from string and array of format strings\n\nexport function configFromStringAndArray(config) {\n  var tempConfig,\n      bestMoment,\n      scoreToBeat,\n      i,\n      currentScore,\n      validFormatFound,\n      bestFormatIsValid = false,\n      configfLen = config._f.length;\n\n  if (configfLen === 0) {\n    getParsingFlags(config).invalidFormat = true;\n    config._d = new Date(NaN);\n    return;\n  }\n\n  for (i = 0; i < configfLen; i++) {\n    currentScore = 0;\n    validFormatFound = false;\n    tempConfig = copyConfig({}, config);\n\n    if (config._useUTC != null) {\n      tempConfig._useUTC = config._useUTC;\n    }\n\n    tempConfig._f = config._f[i];\n    configFromStringAndFormat(tempConfig);\n\n    if (isValid(tempConfig)) {\n      validFormatFound = true;\n    } // if there is any input that was not parsed add a penalty for that format\n\n\n    currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens\n\n    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n    getParsingFlags(tempConfig).score = currentScore;\n\n    if (!bestFormatIsValid) {\n      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n        scoreToBeat = currentScore;\n        bestMoment = tempConfig;\n\n        if (validFormatFound) {\n          bestFormatIsValid = true;\n        }\n      }\n    } else {\n      if (currentScore < scoreToBeat) {\n        scoreToBeat = currentScore;\n        bestMoment = tempConfig;\n      }\n    }\n  }\n\n  extend(config, bestMoment || tempConfig);\n}","map":{"version":3,"names":["copyConfig","configFromStringAndFormat","getParsingFlags","isValid","extend","configFromStringAndArray","config","tempConfig","bestMoment","scoreToBeat","i","currentScore","validFormatFound","bestFormatIsValid","configfLen","_f","length","invalidFormat","_d","Date","NaN","_useUTC","charsLeftOver","unusedTokens","score"],"sources":["/Users/soorena/projects/shared-theme/node_modules/moment/src/lib/create/from-string-and-array.js"],"sourcesContent":["import { copyConfig } from '../moment/constructor';\nimport { configFromStringAndFormat } from './from-string-and-format';\nimport getParsingFlags from './parsing-flags';\nimport { isValid } from './valid';\nimport extend from '../utils/extend';\n\n// date from string and array of format strings\nexport function configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n        scoreToBeat,\n        i,\n        currentScore,\n        validFormatFound,\n        bestFormatIsValid = false,\n        configfLen = config._f.length;\n\n    if (configfLen === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < configfLen; i++) {\n        currentScore = 0;\n        validFormatFound = false;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (isValid(tempConfig)) {\n            validFormatFound = true;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (!bestFormatIsValid) {\n            if (\n                scoreToBeat == null ||\n                currentScore < scoreToBeat ||\n                validFormatFound\n            ) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n                if (validFormatFound) {\n                    bestFormatIsValid = true;\n                }\n            }\n        } else {\n            if (currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,uBAA3B;AACA,SAASC,yBAAT,QAA0C,0BAA1C;AACA,OAAOC,eAAP,MAA4B,iBAA5B;AACA,SAASC,OAAT,QAAwB,SAAxB;AACA,OAAOC,MAAP,MAAmB,iBAAnB,C,CAEA;;AACA,OAAO,SAASC,wBAAT,CAAkCC,MAAlC,EAA0C;EAC7C,IAAIC,UAAJ;EAAA,IACIC,UADJ;EAAA,IAEIC,WAFJ;EAAA,IAGIC,CAHJ;EAAA,IAIIC,YAJJ;EAAA,IAKIC,gBALJ;EAAA,IAMIC,iBAAiB,GAAG,KANxB;EAAA,IAOIC,UAAU,GAAGR,MAAM,CAACS,EAAP,CAAUC,MAP3B;;EASA,IAAIF,UAAU,KAAK,CAAnB,EAAsB;IAClBZ,eAAe,CAACI,MAAD,CAAf,CAAwBW,aAAxB,GAAwC,IAAxC;IACAX,MAAM,CAACY,EAAP,GAAY,IAAIC,IAAJ,CAASC,GAAT,CAAZ;IACA;EACH;;EAED,KAAKV,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGI,UAAhB,EAA4BJ,CAAC,EAA7B,EAAiC;IAC7BC,YAAY,GAAG,CAAf;IACAC,gBAAgB,GAAG,KAAnB;IACAL,UAAU,GAAGP,UAAU,CAAC,EAAD,EAAKM,MAAL,CAAvB;;IACA,IAAIA,MAAM,CAACe,OAAP,IAAkB,IAAtB,EAA4B;MACxBd,UAAU,CAACc,OAAX,GAAqBf,MAAM,CAACe,OAA5B;IACH;;IACDd,UAAU,CAACQ,EAAX,GAAgBT,MAAM,CAACS,EAAP,CAAUL,CAAV,CAAhB;IACAT,yBAAyB,CAACM,UAAD,CAAzB;;IAEA,IAAIJ,OAAO,CAACI,UAAD,CAAX,EAAyB;MACrBK,gBAAgB,GAAG,IAAnB;IACH,CAZ4B,CAc7B;;;IACAD,YAAY,IAAIT,eAAe,CAACK,UAAD,CAAf,CAA4Be,aAA5C,CAf6B,CAiB7B;;IACAX,YAAY,IAAIT,eAAe,CAACK,UAAD,CAAf,CAA4BgB,YAA5B,CAAyCP,MAAzC,GAAkD,EAAlE;IAEAd,eAAe,CAACK,UAAD,CAAf,CAA4BiB,KAA5B,GAAoCb,YAApC;;IAEA,IAAI,CAACE,iBAAL,EAAwB;MACpB,IACIJ,WAAW,IAAI,IAAf,IACAE,YAAY,GAAGF,WADf,IAEAG,gBAHJ,EAIE;QACEH,WAAW,GAAGE,YAAd;QACAH,UAAU,GAAGD,UAAb;;QACA,IAAIK,gBAAJ,EAAsB;UAClBC,iBAAiB,GAAG,IAApB;QACH;MACJ;IACJ,CAZD,MAYO;MACH,IAAIF,YAAY,GAAGF,WAAnB,EAAgC;QAC5BA,WAAW,GAAGE,YAAd;QACAH,UAAU,GAAGD,UAAb;MACH;IACJ;EACJ;;EAEDH,MAAM,CAACE,MAAD,EAASE,UAAU,IAAID,UAAvB,CAAN;AACH"},"metadata":{},"sourceType":"module"}