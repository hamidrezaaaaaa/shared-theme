{"ast":null,"code":"import { configFromISO, configFromRFC2822 } from './from-string';\nimport { configFromArray } from './from-array';\nimport { getParseRegexForToken } from '../parse/regex';\nimport { addTimeToArrayFromToken } from '../parse/token';\nimport { expandFormat, formatTokenFunctions, formattingTokens } from '../format/format';\nimport checkOverflow from './check-overflow';\nimport { YEAR, HOUR } from '../units/constants';\nimport { hooks } from '../utils/hooks';\nimport getParsingFlags from './parsing-flags'; // constant that refers to the ISO standard\n\nhooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form\n\n\nhooks.RFC_2822 = function () {}; // date from string and format string\n\n\nexport function configFromStringAndFormat(config) {\n  // TODO: Move this to another part of the creation flow to prevent circular deps\n  if (config._f === hooks.ISO_8601) {\n    configFromISO(config);\n    return;\n  }\n\n  if (config._f === hooks.RFC_2822) {\n    configFromRFC2822(config);\n    return;\n  }\n\n  config._a = [];\n  getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\n  var string = '' + config._i,\n      i,\n      parsedInput,\n      tokens,\n      token,\n      skipped,\n      stringLength = string.length,\n      totalParsedInputLength = 0,\n      era,\n      tokenLen;\n  tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n  tokenLen = tokens.length;\n\n  for (i = 0; i < tokenLen; i++) {\n    token = tokens[i];\n    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\n    if (parsedInput) {\n      skipped = string.substr(0, string.indexOf(parsedInput));\n\n      if (skipped.length > 0) {\n        getParsingFlags(config).unusedInput.push(skipped);\n      }\n\n      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n      totalParsedInputLength += parsedInput.length;\n    } // don't parse if it's not a known token\n\n\n    if (formatTokenFunctions[token]) {\n      if (parsedInput) {\n        getParsingFlags(config).empty = false;\n      } else {\n        getParsingFlags(config).unusedTokens.push(token);\n      }\n\n      addTimeToArrayFromToken(token, parsedInput, config);\n    } else if (config._strict && !parsedInput) {\n      getParsingFlags(config).unusedTokens.push(token);\n    }\n  } // add remaining unparsed input length to the string\n\n\n  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\n  if (string.length > 0) {\n    getParsingFlags(config).unusedInput.push(string);\n  } // clear _12h flag if hour is <= 12\n\n\n  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n    getParsingFlags(config).bigHour = undefined;\n  }\n\n  getParsingFlags(config).parsedDateParts = config._a.slice(0);\n  getParsingFlags(config).meridiem = config._meridiem; // handle meridiem\n\n  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era\n\n  era = getParsingFlags(config).era;\n\n  if (era !== null) {\n    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n  }\n\n  configFromArray(config);\n  checkOverflow(config);\n}\n\nfunction meridiemFixWrap(locale, hour, meridiem) {\n  var isPm;\n\n  if (meridiem == null) {\n    // nothing to do\n    return hour;\n  }\n\n  if (locale.meridiemHour != null) {\n    return locale.meridiemHour(hour, meridiem);\n  } else if (locale.isPM != null) {\n    // Fallback\n    isPm = locale.isPM(meridiem);\n\n    if (isPm && hour < 12) {\n      hour += 12;\n    }\n\n    if (!isPm && hour === 12) {\n      hour = 0;\n    }\n\n    return hour;\n  } else {\n    // this is not supposed to happen\n    return hour;\n  }\n}","map":{"version":3,"names":["configFromISO","configFromRFC2822","configFromArray","getParseRegexForToken","addTimeToArrayFromToken","expandFormat","formatTokenFunctions","formattingTokens","checkOverflow","YEAR","HOUR","hooks","getParsingFlags","ISO_8601","RFC_2822","configFromStringAndFormat","config","_f","_a","empty","string","_i","i","parsedInput","tokens","token","skipped","stringLength","length","totalParsedInputLength","era","tokenLen","_locale","match","substr","indexOf","unusedInput","push","slice","unusedTokens","_strict","charsLeftOver","bigHour","undefined","parsedDateParts","meridiem","_meridiem","meridiemFixWrap","erasConvertYear","locale","hour","isPm","meridiemHour","isPM"],"sources":["/Users/soorena/projects/shared-theme/node_modules/moment/src/lib/create/from-string-and-format.js"],"sourcesContent":["import { configFromISO, configFromRFC2822 } from './from-string';\nimport { configFromArray } from './from-array';\nimport { getParseRegexForToken } from '../parse/regex';\nimport { addTimeToArrayFromToken } from '../parse/token';\nimport {\n    expandFormat,\n    formatTokenFunctions,\n    formattingTokens,\n} from '../format/format';\nimport checkOverflow from './check-overflow';\nimport { YEAR, HOUR } from '../units/constants';\nimport { hooks } from '../utils/hooks';\nimport getParsingFlags from './parsing-flags';\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nexport function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i,\n        parsedInput,\n        tokens,\n        token,\n        skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0,\n        era,\n        tokenLen;\n\n    tokens =\n        expandFormat(config._f, config._locale).match(formattingTokens) || [];\n    tokenLen = tokens.length;\n    for (i = 0; i < tokenLen; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) ||\n            [])[0];\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(\n                string.indexOf(parsedInput) + parsedInput.length\n            );\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            } else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        } else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver =\n        stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (\n        config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0\n    ) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(\n        config._locale,\n        config._a[HOUR],\n        config._meridiem\n    );\n\n    // handle era\n    era = getParsingFlags(config).era;\n    if (era !== null) {\n        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n    }\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\nfunction meridiemFixWrap(locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}